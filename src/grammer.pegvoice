{
  const {
    ClickCommand,
    I3Command,
    KeyCommand,
    ModeCommand,
    MultiCommand,
    NoopCommand,
    PriorityCommand,
    RecordCommand,
    RepeatCommand,
    SleepCommand,
  } = options.commands;

  function noop() {
    return new NoopCommand();
  }
  function i3(command) {
    return new I3Command(command);
  }
  function repeat(count, command) {
    if (count === 1) {
      return command;
    }
    return new RepeatCommand(count, command);
  }
  function mode(name) {
    return new ModeCommand([name], []);
  }
  function modeOff(name) {
    return new ModeCommand([], [name]);
  }
  function multi(...commands) {
    if (commands.length === 0) {
      return noop();
    } else if (commands.length === 1) {
      return commands[0];
    }
    return new MultiCommand(commands);
  }

  function key(name) {
    return new KeyCommand(name);
  }

  function type(keys) {
    const names = {'\n': 'enter'};
    if (typeof keys === 'string') {
      keys = keys.split('').map(key => {
        return names[key] || key;
      });
    }
    return multi(...keys.map(name => key(name)));
  }
  function typeLine(keys) {
    return multi(type(keys), key('enter'));
  }

  function vimex(command) {
    return escaped(typeLine(`:${command}`));
  }

  function escaped(command) {
    return multi(key('escape'), command);
  }
  function extractList(list, index) {
    return list.map(element => element[index]);
  }
  function extractOptional(optional, index, def=null) {
    return optional ? optional[index] : def;
  }
  function optional(v, def=null) {
    return extractOptional(v, 1, def);
  }
}

wake up => new SleepCommand(false);
go to sleep => new SleepCommand(true);

record on => new RecordCommand(true);
record off => new RecordCommand(false);

click => new ClickCommand();

page down => key('pagedown');
page up => key('pageup');

move window :direction => i3(`move ${direction}`);
close window => i3('kill');

window ...{
  float => i3('floating toggle');
  :direction => i3(`focus ${direction}`);
  move :direction => i3(`move ${direction}`);
  close => i3('kill');
  move screen? :i3screen => i3(`move container to workspace ${i3screen}`);
}

focus floating => i3('focus floating');
focus tiling => i3('focus tiling');

screen lock => multi(i3('exec lock'), new SleepCommand(true));
screen :i3screen => i3(`workspace ${i3screen}, focus tiling`);
screen brightness :number => i3(`exec brightness ${number}`);

open terminal :folder? => i3(
  `exec gnome-terminal --hide-menubar ` +
  `--working-directory="${optional(folder, '/home/josh')}"`
);
open editor :folder? => i3(
  `exec gvim -c ':NERDTree ${optional(folder, '/home/josh')}'`
);
open chrome => i3('exec google-chrome');
open chrome? incognito => i3('exec google-chrome -incognito');

redo => key('ctrl-r');

call :ident => multi(type(`${ident}()`), key('left'));
string :keys => type("'" + keys + "'");
console log => type('console.log(');
arrow function => multi(type(' => '), key('shift-['), key('enter'));
arrow => type(' => ');

slap it? => key('enter');
enter => key('enter');
escape => key('escape');

&slack ...{
  pizza party => type(
    ':party-dino: ' +
    ':pizzaspin: :pizzaspin2: :antipizza: :pizzaspin3: :pizzaspin4:' +
    ' :party-dino:'
  );
}

&chrome ...{
  tab :number => key(`ctrl-${number}`);
  link => escaped(key('f'));
  big link => escaped(key('F'));
  close tab? => key('ctrl-w');
  open tab? => key('ctrl-t');
  undo => key('ctrl-z');
  tab => key('tab');
  page down? => key('pagedown');
  go to :website => multi(key('ctrl-t'), type(website), key('enter'));
  l:letter => key(l);
  k:modified_key => key(k);
  :dictate => dictate;
}

&terminal ...{
  rebase => type('git rebase -i HEAD~25');
  commit all => multi(type('git commit -a -m \'\''), key('left'));
  commit => multi(type('git commit -m \'\''), key('left'));
  copy => key('ctrl-shift-c');
  paste => key('ctrl-shift-v');
  delete line => multi(key('home'), key('ctrl-k'));
  k:modified_key => key(k);
  :dictate => dictate;
}

key k:key => key(k);
k:modified_key => key(k);

type :ascii_string => type(ascii_string);
dictate :dictate => dictate;
word :word => type(word);


&vimVisual ...{
  change => multi(key('c'), modeOff('vim-visual'), mode('vim-insert'));
  delete => multi(key('d'), modeOff('vim-visual'));
  indent => multi(key('>'), modeOff('vim-visual'));
  dedent => multi(key('<'), modeOff('vim-visual'));
  format => multi(key('='), modeOff('vim-visual'));
  replace k:key => multi(key('r'), key(k), modeOff('vim-visual'));
  sort => multi(type(':!sort\n'), modeOff('vim-visual'));
  yank => multi(key('y'), modeOff('vim-visual'));
  unique => multi(type(':!sort\ngv:!uniq\n'), modeOff('vim-visual'));
}

&vim ...{
  exit without save => vimex('q!');
  save exit => vimex('wq');
  save as => escaped(type(':w '));
  save => vimex('w');

  switch buffer => escaped(repeat(2, key('ctrl-w')));
  buffer flip => escaped(key('ctrl-6'));
  close buffer => vimex('bd');
}

&vimNotInsert ...{
  f:vim_find empty line => type(`${f}^$\n`);
  f:vim_find :dictate? => multi(type(f), optional(dictate, noop()));
  previous => type('N');
  next => type('n');

  forward c:ascii => type(`f${c}`);
  back c:ascii => type(`F${c}`);

  mark :letter => type(`m${letter}`);
  go to? ...{
    top => type('gg');
    bottom => type('G');
    :letter => type(`'${letter}`);
  }
}

&vimNormal ...{
  open above => multi(type('O'), mode('vim-insert'));
  open => multi(type('o'), mode('vim-insert'));
  above => multi(type('O'), mode('vim-insert'));
  append end => multi(type('A'), mode('vim-insert'));
  append => multi(type('a'), mode('vim-insert'));
  insert => multi(type('i'), mode('vim-insert'));
  big replace => multi(type('R'), mode('vim-insert'));

  :number => type(`${number}`);

  create macro :letter => type(`q${letter}`);
  macro :letter => type(`q${letter}`);
  play :letter => type(`@${letter}`);
  end macro => type(`q`);

  cut => type('x');
  replace k:key => multi(key('r'), key(k));

  paste from k:ascii => type(`${k}+p`);
  big paste => type('P');
  paste => type('p');

  repeat => type('.');
  undo => type('u');

  visual block => multi(key('ctrl-v'), mode('vim-visual'));
  visual line => multi(type('V'), mode('vim-visual'));
  visual => multi(type('v'), mode('vim-visual'));
  reselect => multi(type('gv'), mode('vim-visual'));

  tree :folder? => vimex(`NERDTree ${optional(folder, '/home/josh')}`);
  file :folder? => vimex(`FZF ${optional(folder, '/home/josh')}`);

  big change => key('C');
  change ...{
    line => multi(type('cc'), mode('vim-insert'));
    dir:vim_direction => multi(type(`c${dir}`), mode('vim-insert'));
  }
  big delete => key('D');
  delete ...{
    line => type('dd');
    dir:vim_direction => type(`d${dir}`);
  }
  big yank => key('Y');
  yank ...{
    line => type('yy');
    dir:vim_direction => type(`y${dir}`);
  }

  indent ...{
    line => type('>>');
    dir:vim_direction => type(`>${dir}`);
  }
  dedent ...{
    line => type('<<');
    dir:vim_direction => type(`<${dir}`);
  }

  :editor_movement => editor_movement;
  :ascii => key(ascii);
}

&vimTree ...{
  change => type('C');
  open => type('o');
}
&vimRebase ...{
  cmd:rebase_command => multi(type(`cw${cmd}`), key('escape'), key('enter'));
}
&vimInsert ...{
  node require :ident => typeLine(`const ${ident} = require('${ident}');`);
  delete => key('delete');
  paste => key('ctrl-shift-v');
  :dictate => dictate;
}

:editor_movement => editor_movement;

/***
  DEFINITIONS
***/

_modified_key
  = capital _ k:_key { return `shift-${k}`; }
  / alt _ k:_key { return `alt-${k}`; }
  / control _ alt _ k:_key { return `ctrl-alt-${k}`; }
  / control _ k:_key { return `ctrl-${k}`; }
  / shift k_ :_key { return `shift-${k}`; }

_editor_movement = count:(_count _) k:(_direction / backspace / space / slap) {
  return repeat(extractOptional(count, 0, 1), key({
    slap: 'enter',
  }[k] || k));
}

_website
  = gmail { return "https://mail.google.com" }
  / reddit word:(_ _word) {
    return "https://www.reddit.com" + (word ? `/r/${word[1]}` : '');
  };

:direction => key(direction);
:count :direction => repeat(count, key(direction));
backspace => key('backspace');
:count backspace => repeat(count, key('backspace'));

_vim_find = find prev:(_ previous)? {
  return prev ? '?' : '/';
}

_vim_direction = pos:((_vim_inside / _vim_around) _)? dir:(
  word / _paren / _vim_until / _vim_including / _right_paren
) {
  return extractOptional(pos, 0, '') + ({
    word: 'w',
  }[dir] || dir);
}

_vim_inside = (inner / inside / in) { return 'i'; }
_vim_around = (around / outside) { return 'a'; }

_vim_including = (including) _ code:_ascii {
  return `f${code}`;
}
_vim_until = (to / until) _ code:_ascii {
  return `t${code}`;
}

_chrome = &{
  return options.mode.has('chrome');
};
_slack = &{
  return options.mode.has('slack');
};
_vim = &{
  return options.mode.has('vim');
};
_vimNormal = &{
  return (
    options.mode.has('vim') &&
    !options.mode.has('vim-insert') &&
    !options.mode.has('vim-visual')
  );
};
_vimNotInsert = &{
  return (
    options.mode.has('vim') &&
    !options.mode.has('vim-insert')
  );
};
_terminal = &{
  return options.mode.has('terminal');
};
_vimInsert = &{
  return options.mode.has('vim-insert');
};
_vimVisual = &{
  return options.mode.has('vim-visual');
};
_vimTree = &{
  return options.mode.has('vim-tree');
};
_vimRebase = &{
  return options.mode.has('vim-rebase');
};

_folder = folder:(voice / _authbox) {
  return {
    voice: "/home/josh/pegvoice/src",
  }[folder] || folder;
}

_authbox = box sub:(_ _authbox_subfolder)? {
  return "/home/josh/authbox" + extractOptional(sub, 1, '');
}

_authbox_subfolder 
  = lib { return "/authbox-api/lib"; }
  / tests { return "/authbox-api/tests"; }
  / apps { return "/apps"; }
  / (s / sierra) { return "/apps/s"; }
  / config { return "/config"; }

_direction = (up / down / left / right);
_i3screen = screen:(_number / dash / equal) {
  return {
    dash: '-',
    equal: '=',
  }[screen] || screen;
};

_keys = head:_key "."? tail:(_ _key "."?)* {
  return [head, ...extractList(tail, 1)];
}

_dictate = head:_dictate_command tail:(_ _dictate_command &_)* {
  return multi(head, ...extractList(tail, 1));
}

_dictate_command
  = _dictate_special
  / _dictate_compare
  / word _ w:_word { return type(w); }
  / type _ s:_ascii_string { return type(s); }
  / key _ k:_key { return key(k); }
  / k:_modified_key { return key(k); }
  / c:_count _ v:_dictate_repeatable { return repeat(c, v); }
  / _dictate_number
  / k:_key { return key(k); }
  / _dictate_repeatable
  / _dictate_ident;

_dictate_compare = w:(greater / less) equal:((_ or)? _ equal)? {
  return type(' ' + ({
    greater: '>',
    less: '<',
  }[w]) + (equal ? '=' : '') + ' ');
}

_dictate_special = w:(equal_to / equal / not_equal / arrow / dotcom) &_ {
  return type({
    dotcom: '.com',
    equal_to: ' === ',
    equal: ' = ',
    not_equal: ' !== ',
    greater: ' > ',
    less: ' < ',
    arrow: ' => ',
    or: ' || ',
    and: ' && ',
  }[w]);
}

_dictate_ident = w:_ident &_ {
  return type(w);
}

_dictate_repeatable = k:(_direction / backspace / space / slap) {
  return key({
    slap: 'enter',
  }[k] || k);
}

_dictate_number = (number _)? head:_number tail:(_ _number)* &_ {
  return type([head, ...extractList(tail, 1)].join(''));
}

_ident = word:_word {
  return word.toLowerCase();
}

_word = (!_ .)+ &_ {
  // Take the first entry dragon returns
  return text().split('\\')[0].toLowerCase();
}

_rebase_command = (pick / squash / reword / edit / drop);

_key "<key>" 
  = enter
  / escape
  / backspace
  / home
  / end
  / _paren
  / _direction
  / _ascii;

_paren = char:(
  left_curly /
  left_paren /
  left_square /
  left_triangle /
  right_curly /
  right_paren /
  right_square /
  right_triangle
) &_ {
  return {
    left_curly: '{',
    left_paren: '(',
    left_square: '[',
    left_triangle: '<',
    right_curly: '}',
    right_paren: ')',
    right_square: ']',
    right_triangle: '>',
  }[char];
}

_ascii_string = head:_ascii tail:(_ _ascii)* {
  return [head, ...extractList(tail, 1)].join('');
}

_ascii "<ascii>" = char:(
  and /
  at /
  backslash /
  backtick /
  caret /
  comma /
  dash /
  dollar /
  exclamation /
  equal /
  greater /
  hash /
  less /
  percent /
  period /
  pipe /
  plus /
  question /
  semicolon /
  slash /
  space /
  star /
  tab /
  tilde /
  underscore /
  quote /
  big_quote /
  _paren /
  _digit /
  _letter
) {
  return {
    and: '&',
    at: '@',
    backslash: '\\',
    big_quote: '"',
    caret: '^',
    comma: ',',
    dash: '-',
    dollar: '$',
    equal: '=',
    exclamation: '!',
    greater: '>',
    hash: '#',
    less: '<',
    percent: '%',
    period: '.',
    pipe: '|',
    plus: '+',
    question: '?',
    quote: '\'',
    semicolon: ';',
    slash: '/',
    space: ' ',
    star: '*',
    tab: '\t',
    tilde: '~',
    underscore: '_',
  }[char] || `${char}`;
}

_letter = _phonetic_letter / _alphabet_letter;

_phonetic_letter = capital:((big / capital) _)? code:(
  alfa /
  bravo /
  charlie /
  delta /
  echo /
  foxtrot /
  golf /
  hotel /
  india /
  juliett /
  kilo /
  lima /
  mike /
  november /
  oscar /
  papa /
  quebec /
  romeo /
  sierra /
  tango /
  uniform /
  victor /
  whiskey /
  xray /
  yankee /
  zulu
) &_ {
  const letter = code.charAt(0).toLowerCase();
  return capital ? letter.toUpperCase() : letter;;
};

_alphabet_letter = capital:((big / capital) _)? letter:(
    a / b / c / d / e / f / g / h / i / j / k / l / m /
    n / o / p / q / r / s / t / u / v / w / x / y / z
) {
  if (text().includes('uppercase-letter')) {
    capital = true;
  }

  return capital ? letter.toUpperCase() : letter.toLowerCase();
};


_count = _tuple_length / _number;

_tuple_length = length:(single / double / triple) &_ {
  return {
    "single": 1,
    "double": 2,
    "triple": 3,
  }[length];
}

_number = _number_hundred_word / _number_hundred / _number_ten;

_number_hundred_word = a _ hundred { return 100; }
_number_hundred = hundred:(_number_ten _ "hundred" (_ "and")?) ten:(_ _number_ten)? {
  let number = 0;
  if (hundred) {
    number += hundred[0] * 100;
  }
  return number + (ten ? ten[1] : 0);
}


_number_ten = _number_ten_word / _number_ten_combo / _digit;

_number_ten_word = word:(
    "ten"i / "eleven"i / "twelve"i / "thirteen"i / "fourteen"i / "fifteen"i /
    "sixteen"i / "seventeen"i / "eighteen"i / "nineteen"i
) {
  return {
    "ten": 10,
    "eleven": 11,
    "twelve": 12,
    "thirteen": 13,
    "fourteen": 14,
    "fifteen": 15,
    "sixteen": 16,
    "seventeen": 17,
    "eighteen": 18,
    "nineteen": 19,
  }[word.toLowerCase()];
};

_number_ten_combo = word:(
  ten / twenty / thirty / fourty / fifty /
  sixty / seventy / eighty / ninety
) digit:(_ _digit)? {
  return {
    twenty: 20,
    thirty: 30,
    fourty: 40,
    fifty: 50,
    sixty: 60,
    seventy: 70,
    eighty: 80,
    ninety: 90,
  }[word.toLowerCase()] + (extractOptional(digit, 1) || 0);
}

_digit = word:(
  one / two / three / four / five /
  six / seven / eight / nine / naught / zero /
  "1" / "2" / "3" / "4" / "5" / "6" / "7" / "8" / "9" / "0"
) _dragon? {
  const digits = {
    "one": 1,
    "two": 2,
    "three": 3,
    "four": 4,
    "five": 5,
    "six": 6,
    "seven": 7,
    "eight": 8,
    "nine": 9,
    "zero": 0,
    "naught": 0,
  };
  return digits.hasOwnProperty(word) ? digits[word] : parseInt(word, 10);
}

_right_paren = char:(
  curly /
  paren /
  square /
  triangle
) &_ {
  return {
    /* { <= needed for peg rule parsing bug */
    curly: '}',
    paren: ')',
    square: ']',
    triangle: '>',
  }[char];
}
left_curly    = (left _ curly    / "{" _dragon?) &_ { return "left_curly"; }
left_paren    = (left _ paren    / "(" _dragon?) &_ { return "left_paren"; }
left_square   = (left _ square   / "[" _dragon?) &_ { return "left_square"; }
left_triangle = (left _ triangle / "<" _dragon?) &_ { return "left_triangle"; }
right_curly    = (right _ curly    / "}" _dragon?) &_ { return "right_curly"; }
right_paren    = (right _ paren    / ")" _dragon?) &_ { return "right_paren"; }
right_square   = (right _ square   / "]" _dragon?) &_ { return "right_square"; }
right_triangle = (right _ triangle / ">" _dragon?) &_ { return "right_triangle"; }

exit = ("exit"i / x _ it) { return "exit"; }
undo = ("undo"i / and _ do / under) { return "undo"; }
not_equal = not _ equal { return "not_equal"; }
equal_to = equal _ to { return "equal_to"; }
big_quote = big _ quote { return "big_quote"; }

spell a;
spell alt;
spell and;
spell apps;
spell around;
spell arrow;
spell at;
spell backslash / "\\" / "\\backslash\\backslash";
spell backspace / back space / that space / backtrace;
spell backtick / "`\\backquote\\back tick";
spell b / be;
spell box;
spell capital;
spell caret / carrot / "^\\caret\\caret";
spell close / closed;
spell comma / ",";
spell config;
spell control;
spell create / great;
spell c / see;
spell curly;
spell d;
spell dash / "-" / "–\\dash\\dash";
spell dedent / decent / "didn't" / the dent;
spell dictate / dictates;
spell do;
spell dollar;
spell dotcom / ".com\\\\dot com";
spell double;
spell down / dance;
spell drop;
spell e;
spell edit;
spell eight / it;
spell eighty;
spell end;
spell enter / inter / into / "\\new-line\\new line";
spell equal / equals;
spell escape / escaped;
spell exclamation;
spell f;
spell fifty;
spell find;
spell five;
spell forward;
spell four / for;
spell fourty / forty;
spell g;
spell greater / grader / grade or;
spell h;
spell hash;
spell home;
spell hundred;
spell i;
spell in;
spell including;
spell inner;
spell inside;
spell j;
spell k;
spell key / he;
spell l / al;
spell left;
spell less;
spell lib / lab;
spell line / lines;
spell m;
spell n;
spell naught / nought;
spell nine;
spell ninety;
spell not;
spell number;
spell one;
spell o / oh;
spell or;
spell outside;
spell p;
spell paren;
spell paste / based;
spell percent;
spell period / "." / ".\\dot\\dot";
spell pick / pip;
spell pipe;
spell plus;
spell q;
spell question;
spell quote / quotes;
spell r / are;
spell rebase / "we base";
spell reword;
spell right;
spell s;
spell save / safe / saved;
spell screen / green;
spell semicolon / ";\\semicolon\\semicolon";
spell seven;
spell seventy;
spell shift;
spell single;
spell six;
spell sixty;
spell slash / "/" / "/\\slash\\slash";
spell space;
spell square;
spell squash;
spell star;
spell t;
spell tab / "\\tab-key\\tab key";
spell ten;
spell tests;
spell than;
spell thirty;
spell three;
spell tilde / "~\\tilde\\tilde";
spell to / do;
spell tree / treat;
spell triangle;
spell triple;
spell twenty;
spell two / to;
spell u;
spell under;
spell underscore / "_" / "_\\underscore\\underscore";
spell until;
spell up;
spell v;
spell voice;
spell w;
spell window / windows;
spell word / words;
spell x;
spell y;
spell zero;
spell z / said;
spell gmail;
spell reddit;

spell alfa / alpha / offer / of the;
spell bravo / brother;
spell charlie;
spell delta;
spell echo;
spell foxtrot;
spell golf;
spell hotel;
spell india;
spell juliett / juliet;
spell kilo;
spell lima;
spell mike;
spell november;
spell oscar;
spell papa / pepper;
spell quebec / "québec";
spell romeo;
spell sierra;
spell tango;
spell uniform;
spell victor;
spell whiskey;
spell xray / "x-ray";
spell yankee;
spell zulu / sooner;

_dragon = "\\" (!_ [ -~])+ &_;
