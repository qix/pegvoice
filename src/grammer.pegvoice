{
  const {
    NoopCommand,
    I3Command,
    RepeatCommand,
    KeyCommand,
    ModeCommand,
    MultiCommand,
  } = options.commands;

  function noop() {
    return new NoopCommand();
  }
  function i3(command) {
    return new I3Command(command);
  }
  function repeat(count, command) {
    if (count === 1) {
      return command;
    }
    return new RepeatCommand(count, command);
  }
  function mode(name) {
    return new ModeCommand([name], []);
  }
  function modeOff(name) {
    return new ModeCommand([], [name]);
  }
  function multi(...commands) {
    if (commands.length === 0) {
      return noop();
    } else if (commands.length === 1) {
      return commands[0];
    }
    return new MultiCommand(commands);
  }

  function key(name) {
    return new KeyCommand(name);
  }

  function type(keys) {
    const names = {'\n': 'enter'};
    if (typeof keys === 'string') {
      keys = keys.split('').map(key => {
        return names[key] || key;
      });
    }
    return multi(...keys.map(name => key(name)));
  }
  function typeLine(keys) {
    return multi(type(keys), key('enter'));
  }

  function vimex(command) {
    return escaped(typeLine(`:${command}`));
  }

  function escaped(command) {
    return multi(key('escape'), command);
  }
  function extractList(list, index) {
    return list.map(element => element[index]);
  }
  function extractOptional(optional, index, def=null) {
    return optional ? optional[index] : def;
  }
  function optional(v, def=null) {
    return extractOptional(v, 1, def);
  }
}

wake up => noop();
go to sleep => noop();

page down => key('pagedown');
page up => key('pageup');

move window :direction => i3(`move ${direction}`);

window ...{
  float => i3('floating toggle');
  :direction => i3(`focus ${direction}`);
  move :direction => i3(`move ${direction}`);
  close => i3('kill');
  move screen? :i3screen => i3(`move container to workspace ${i3screen}`);
}

screen :i3screen => i3(`workspace ${i3screen}`);
screen brightness :number => i3(`exec brightness ${number}`);

open terminal :folder? => i3(
  `exec gnome-terminal --hide-menubar ` +
  `--working-directory="${optional(folder, '/home/josh')}"`
);
open editor :folder? => i3(
  `exec gvim -c ':NERDTree ${optional(folder, '/home/josh')}'`
);
open chrome => i3('exec google-chrome');
open chrome? incognito => i3('exec google-chrome -incognito');

redo => key('ctrl-r');

call :ident => multi(type(`${ident}()`), key('left'));
string :keys => type("'" + keys + "'");
console log => type('console.log(');
arrow function => multi(type(' => '), key('shift-['), key('enter'));
arrow => type(' => ');

endvim => noop();

slap it? => key('enter');
enter => key('enter');
escape => key('escape');

&chrome ...{
  tab :number => key(`ctrl-${number}`);
  link => escaped(key('f'));
  big link => escaped(key('F'));
  l:phonetic_letter => key(l);
  close tab? => key('ctrl-w');
  open tab? => key('ctrl-t');
  tab => key('tab');
  page down? => key('pagedown');
}
&slack ...{
  pizza party => type(
    ':party-dino: ' +
    ':pizzaspin: :pizzaspin2: :antipizza: :pizzaspin3: :pizzaspin4:' +
    ' :party-dino:'
  );
}

i three ...{
  screen :i3screen => i3(`workspace ${i3screen}`);
}

key k:key => key(k);

capital k:key => key(`shift-${k}`);
alt k:key => key(`alt-${k}`);
control alt k:key => key(`ctrl-alt-${k}`);
control k:key => key(`ctrl-${k}`);
shift k:key => key(`shift-${k}`);

type :keys => type(keys);
dictate :dictate => dictate;
words :string => type(string);

&vimVisual ...{
  change => multi(key('c'), modeOff('vim-visual'), mode('vim-insert'));
  delete => multi(key('d'), modeOff('vim-visual'));
  yank => multi(key('y'), modeOff('vim-visual'));
}

&vim ...{

  save exit => vimex('wq');
  save as => escaped(type(':w '));
  save => vimex('w');



  tree :folder => vimex(`NERDTree ${folder}`);

  switch buffer => escaped(repeat(2, key('ctrl-w')));
  close buffer => vimex('bd');
  find :code? => escaped(type(`/${optional(code, '')}`));
  next => type('n');
}

&vimNormal ...{
  open above => multi(type('O'), mode('vim-insert'));
  open => multi(type('o'), mode('vim-insert'));
  above => multi(type('O'), mode('vim-insert'));
  append end => multi(type('A'), mode('vim-insert'));
  append => multi(type('a'), mode('vim-insert'));
  insert => multi(type('i'), mode('vim-insert'));
  big replace => multi(type('R'), mode('vim-insert'));

  paste => type('p');
  repeat => type('.');
  undo => type('u');

  replace k:key => multi(key('r'), key(k));

  visual block => multi(key('ctrl-v'), mode('vim-visual'));
  visual line => multi(type('V'), mode('vim-visual'));
  visual => multi(type('v'), mode('vim-visual'));

  macro :phonetic_letter => type(`q${phonetic_letter}`);
  forward c:ascii => type(`f${c}`);
  go to? ...{
    top => type('gg');
    bottom => type('G');
  }
  change ...{
    line => multi(type('cc'), mode('vim-insert'));
    dir:vim_direction => multi(type(`c${dir}`), mode('vim-insert'));
  }
  delete ...{
    line => type('dd');
    dir:vim_direction => type(`d${dir}`);
  }
  yank ...{
    line => type('yy');
    dir:vim_direction => type(`y${dir}`);
  }
}

&vimTree ...{
  change => type('C');
}
&vimInsert ...{
  node require :ident => typeLine(`const ${ident} = require('${ident}');`);
  :dictate => dictate;
}

:direction => key(direction);
:count :direction => repeat(count, key(direction));
backspace => key('backspace');
:count backspace => repeat(count, key('backspace'));

/***
  DEFINITIONS
***/

_vim_direction = inner:(inner _)? dir:(word / _vim_until) {
  return (inner ? 'i' : '') + ({
    word: 'w',
  }[dir] || dir);
}

_vim_until = (to / until) _ code:_ascii {
  return `t${code}`;
}

_chrome = &{
  return options.mode.has('chrome');
};
_slack = &{
  return options.mode.has('slack');
};
_vim = &{
  return options.mode.has('vim');
};
_vimNormal = &{
  return (
    options.mode.has('vim') &&
    !options.mode.has('vim-insert') &&
    !options.mode.has('vim-visual')
  );
};
_vimInsert = &{
  return options.mode.has('vim-insert');
};
_vimVisual = &{
  return options.mode.has('vim-visual');
};
_vimTree = &{
  return options.mode.has('vim-tree');
};

_folder = voice {
  return "/home/josh/voice-code/pegvoice";
}
_direction = (up / down / left / right);
_i3screen = _number;

_keys = head:_key "."? tail:(_ _key "."?)* {
  return [head, ...extractList(tail, 1)];
}

_code = head:_ident tail:(_ _ident &_)* {
  return [head, ...extractList(tail, 1)].join(' ');
}

_dictate = commands:(
  _dictate_special /
  _dictate_compare /
  _dictate_number /
  _dictate_key /
  _dictate_ident
)+ {
  return multi(...commands);
}

_dictate_compare = w:(greater / less) equal:((_ or)? _ equal)? {
  return type(' ' + ({
    greater: '>',
    less: '<',
  }[w]) + (equal ? '=' : '') + ' ');
}

_dictate_special = w:(equal / not_equal / arrow / dotcom) &_ {
  return type({
    dotcom: '.com',
    equal: ' === ',
    not_equal: ' !== ',
    greater: ' > ',
    less: ' < ',
    arrow: ' => ',
  }[w]);
}

_dictate_ident = w:_ident &_ {
  return type(w);
}
_dictate_key = count:(_count _)? k:_key &_ {
  return repeat(extractOptional(count, 0, 1), key(k));
}

_dictate_number = (number _)? head:_number tail:(_ _number)* &_ {
  return type([head, ...extractList(tail, 1)].join(''));
}

_ident = word:_word {
  return word.toLowerCase();
}

_word = [A-Za-z]+ {
  return text();
}

_key "<key>" 
  = enter
  / escape
  / backspace
  / _paren
  / _direction
  / _ascii;

_paren = char:(
  left_curly /
  left_paren /
  left_square /
  left_triangle /
  right_curly /
  right_paren /
  right_square /
  right_triangle
) &_ {
  return {
    left_curly: '{',
    left_paren: '(',
    left_square: '[',
    left_triangle: '<',
    right_curly: '}',
    right_paren: ')',
    right_square: ']',
    right_triangle: '>',
  }[char];
}

_ascii "<ascii>" = char:(
  and /
  at /
  backslash /
  backtick /
  caret /
  dash /
  dollar /
  exclamation /
  equal /
  greater /
  hash /
  less /
  percent /
  period /
  pipe /
  plus /
  question /
  semicolon /
  slash /
  space /
  star /
  tab /
  tilde /
  underscore /
  _paren /
  _digit /
  _phonetic_letter /
  _letter
) {
  return {
    and: '&',
    at: '@',
    backslash: '\\',
    caret: '^',
    dash: '-',
    dollar: '$',
    equal: '=',
    exclamation: '!',
    greater: '>',
    hash: '#',
    less: '<',
    percent: '%',
    period: '.',
    pipe: '|',
    plus: '+',
    question: '?',
    semicolon: ';',
    slash: '/',
    space: ' ',
    star: '*',
    tab: '\t',
    tilde: '~',
    underscore: '_',
  }[char] || `${char}`;
}

_phonetic_letter = code:(
  alfa /
  bravo /
  charlie /
  delta /
  echo /
  foxtrot /
  golf /
  hotel /
  india /
  juliett /
  kilo /
  lima /
  mike /
  november /
  oscar /
  papa /
  quebec /
  romeo /
  sierra /
  tango /
  uniform /
  victor /
  whiskey /
  xray /
  yankee /
  zulu
) &_ {
  return code.toLowerCase().charAt(0);
};


_letter = capital:(capital _)? letter:([a-zA-Z]) (
  "\\determiner" /
  "\\letter\\letter [A-Z]" /
  "\\letter" /
  "\\pronoun" /
  ("\\spelling-letter\\letter " [A-Z]) /
  ("\\spelling-letter\\" [A-Z]) /
  ("\\uppercase-letter\\capital " [A-Z])
)? &_ {
  if (text().includes('uppercase-letter')) {
    capital = true;
  }

  return capital ? letter.toUpperCase() : letter.toLowerCase();
};


_count = _tuple_length / _number;

_tuple_length = length:(single / double / triple) &_ {
  return {
    "single": 1,
    "double": 2,
    "triple": 3,
  }[length];
}

_number = _number_hundred / _number_ten;

_number_hundred = hundred:(_number_ten _ "hundred" (_ "and")? _) ten:_number_ten? {
  let number = 0;
  if (hundred) {
    number += hundred[0] * 100;
  }
  return number + (ten || 0);
}


_number_ten = _number_ten_word / _number_ten_combo / _digit;

_number_ten_word = word:(
    "ten"i / "eleven"i / "twelve"i / "thirteen"i / "fourteen"i / "fifteen"i /
    "sixteen"i / "seventeen"i / "eighteen"i / "nineteen"i
) {
  return {
    "ten": 10,
    "eleven": 11,
    "twelve": 12,
    "thirteen": 13,
    "fourteen": 14,
    "fifteen": 15,
    "sixteen": 16,
    "seventeen": 17,
    "eighteen": 18,
    "nineteen": 19,
  }[word.toLowerCase()];
};

_number_ten_combo = word:(
  "ten"i / "twenty"i / "thirty"i / "fourty"i / "fifty"i /
  "sixty"i / "seventy"i / "eighty"i / "ninety"i
) digit:(_ _digit)? {
  return {
    twenty: 20,
    thirty: 30,
    fourty: 40,
    fifty: 50,
    sixty: 60,
    seventy: 70,
    eighty: 80,
    ninety: 90,
  }[word.toLowerCase()] + (extractOptional(digit, 1) || 0);
}

_digit = word:(
  one / two / three / four / five /
  six / seven / eight / nine / naught / zero /
  "1" / "2" / "3" / "4" / "5" / "6" / "7" / "8" / "9" / "0"
) ("\\number" / "\\pronoun")? {
  const digits = {
    "one": 1,
    "two": 2,
    "three": 3,
    "four": 4,
    "five": 5,
    "six": 6,
    "seven": 7,
    "eight": 8,
    "nine": 9,
    "zero": 0,
    "naught": 0,
  };
  return digits.hasOwnProperty(word) ? digits[word] : parseInt(word, 10);
}

_string = chars:(.*) {
  return chars.join('');
}

undo = ("undo"i / and _ do) { return "undo"; }
not_equal = not _ equal { return "not_equal"; }
left_curly    = (left _ curly    / "{" _dragon?) &_ { return "left_curly"; }
left_paren    = (left _ paren    / "(" _dragon?) &_ { return "left_paren"; }
left_square   = (left _ square   / "[" _dragon?) &_ { return "left_square"; }
left_triangle = (left _ triangle / "<" _dragon?) &_ { return "left_triangle"; }
right_curly    = (right _ curly    / "}" _dragon?) &_ { return "right_curly"; }
right_paren    = (right _ paren    / ")" _dragon?) &_ { return "right_paren"; }
right_square   = (right _ square   / "]" _dragon?) &_ { return "right_square"; }
right_triangle = (right _ triangle / ">" _dragon?) &_ { return "right_triangle"; }


_dragon = "\\" [ -~]+ &_;

spell and;
spell arrow;
spell at;
spell backslash / "\\" / "\\backslash\\backslash";
spell backspace / back space / that space;
spell backtick / "`\\backquote\\back tick";
spell capital;
spell caret / carrot / "^\\caret\\caret";
spell close / closed;
spell dash / "-" / "–\\dash\\dash";
spell dictate / dictates;
spell do;
spell dollar;
spell dotcom / ".com\\\\dot com";
spell double;
spell down;
spell eight;
spell enter / inter / into / "\\new-line\\new line";
spell equal / equals;
spell escape / escaped;
spell exclamation;
spell five;
spell forward;
spell four / for;
spell greater / grader;
spell hash;
spell inner;
spell key / he;
spell left;
spell curly;
spell paren;
spell square;
spell triangle;
spell less;
spell naught / nought;
spell nine;
spell not;
spell number;
spell one;
spell or;
spell percent;
spell period / "." / ".\\dot\\dot";
spell pipe;
spell plus;
spell question;
spell right;
spell save / safe / saved;
spell semicolon / ";\\semicolon\\semicolon";
spell seven;
spell single;
spell six;
spell slash / "/" / "/\\slash\\slash";
spell space;
spell star;
spell tab / "\\tab-key\\tab key";
spell than;
spell three;
spell tilde / "~\\tilde\\tilde";
spell triple;
spell two;
spell underscore / "_" / "_\\underscore\\underscore";
spell until;
spell up;
spell voice;
spell window / windows;
spell word;
spell zero;
spell screen / green;

spell alfa / alpha / offer;
spell bravo / brother;
spell charlie;
spell delta;
spell echo;
spell foxtrot;
spell golf;
spell hotel;
spell india;
spell juliett / juliet;
spell kilo;
spell lima;
spell mike;
spell november;
spell oscar;
spell papa / pepper;
spell quebec / "québec";
spell romeo;
spell sierra;
spell tango;
spell uniform;
spell victor;
spell whiskey;
spell xray / "x-ray";
spell yankee;
spell zulu / sooner;
